클래스타입변환
자동타입변환

강제타입변환
-부모타입으로 반환을 했지만 자식 클래스의 멤버에 접근하고 싶을 때가 있을 수 있다.
-자바의 규약으로 자식 클래스의 멤버에 접근할 수 없으므로 이러한 경우 
 다시 자식타입으로 변경해서 접근할 수 있도록 해야 한다.
-우리는 이를 '클래스의 강제 타입 변환'이라고 부른다.
-자식 객체가 부모타입으로 자동 타입 변환을 한 후, 다시 자식 타입으로 변환하는 것을 말한다.

일회성을 타입 변환이 필요할 때
((자식클래스명)객체명).메서드명();
여기서 객체명 ->부모타입으로 변환한 자식객체

자식클래스의 멤버에 접근이 여러번 필요한 경우
객체명 = (자식클래스명)부모타입객체;

다형성
-객체 지향 프로그래밍의 대표적인 특징 중 하나로, 하나의 타입으로 다양한 객체를 사용할 수 있다는 것을 의미
-자바에서는 클래스 타입 변환을 통해, 부모 클래스 타입 하나로 여러 가지 자식 객체들을 참조하여 사용함으로써
 다형성을 구현할 수 있다.
-완벽한 다형성을 구현하기 위해 상속 + 오버라이딩 + 클래스 타입변환의 세가지 개념을 합쳐야 한다.
-객체가 특정 클래스의 필드가 되면서, 하나의 부품처럼 사용될 수 있다.
-이때, 부품을 교체할 일이 생긴다면 우리는 다형성을 구현함으로써 코드 수정을 최소화할 수 있다.

istancof연산자
-부모타입으로 변환되어 저정된 변수는 안에 어떤 객체가 담겨있는지 직접 확인하지 않는 이상 
 내부 객체를 알기 쉽지 않다.
-오버라이딩된 메서드가 있다면 확인이 쉽겠지만, 부모클래스를 같이 상속받고 있는 
 다른 클래스 또는 부모클래스와 구별할 수 있는 특정 멤버가 없다면 어떻게 구별해야 할까?

instanceof연산자의 특징
A instanceof B : A 객체가 생성될 때 B 타입으로 생성되었는지 확인하는 연산자
맞으면 true, 아니면 false를 반환하며 만약 null을 가리키고 있으면 false를 반환한다.

객체 instanceof 클래스명

instanceof 연산자와 '=='연산자의 차이
A instanceof B : 객체변수 A가 객체의 타입 B로 생성된것인지 확인
A == B : 객체 변수 A와 객체 변수 B가 같은 객체를 참조하고 있는지 확인한다.


오버로딩/오버라이딩
-객체 지향 프로그래밍에서 다형성을 얘기할 때 빼놓을 수 없는 것이 바로 오버로딩과 오버라이딩이다.
-비슷한 기능을 하고 중복되는 구현이 필요하지만 우리는 오버로딩과 오버라이딩을 적절히 사용할 수 있다면, 
 중복이 없는 최소한의 코드로 원하는 기능을 모두 구현해낼 수 있다.

오버로딩
-자바는 매개변수의 자료형/개수/순서를 기반으로 메서드를 구별하므로 하나의 클래스 안에서 
 같은 이름의 메서드를 여러 개 구현하고 필요에 따라 메서드를 선택해 사용할 수 있다

오버라이딩
-부모 클래스에게 상속받은 메서드를 재정의하여 자식 클래스용 메서드를 구현하고 
 자식 객체를 통해 메서드를 호출하면 오버라이딩된 메서드가 호출된다.

추상화
-공통성과 본질을 모아 추출하는것
-기존 클래스들의 공통적인 요소를 모아 상위 클래스를 만들어내는 기술
-공통적인 속성과 행위를 모아 정의하면, 반복적인 코드를 줄일수 있고, 
 보다 효과적인 클래스간의 관계를 설정하여 유지보수가 용이해진다.

추상메서드
-선언부만 작성하고 구현부는 작성하지 않고 남겨둔 미완성의 메서드
-다형성을 위해 메서드의 선언은 통일해야 하지만, 실제로 구현하는 내용은 자식 클래스마다 달라야 할때 사용
-부모 클래스의 메서드는 비워두고 자식 클래스에서 오버라이딩하여 구현을 할 수 있다.
-추상 메서드를 선언할 때 abstract 키워드를 함께 표기해야 한다.
-또한 메서드의 구현부인 중괄호{} 대신 구현부가 없다는 의미로 세미콜론(;)를 쓴다.


접근제한자  abstract 반환형 메서드명(매개변수);
abstract 접근제한자 abstract 반환형 메서드명(매개변수);
 -> 둘 다 사용가능

추상클래스
-추상메서드가 한 개 이상 정의되어 있는 클래스를 추상 클래스라고 한다.
-추상 메서드를 포함하고 있다는 것을 제외하고 일반 클래스와 다르지 않다.
-추상 클래스에도 생성자가 있으며, 멤버변수와 메서드도 가질 수 있다.
-추상 클래스 또한 abstract를 통해 자신이 추상클래스임을 명시해줘야 한다.

public abstract class 클래스명{
	//필드
	//생성자
	//메서드(추상메서드 포함)
}

추상 클래스의 특징
-일반 클래스처럼 독립적으로 생성자를 호출해 객체를 생성 할 수 없다.
-자식 클래스의 생성자 super()를 통해 추상 클래스의 생성자를 호출하여
 부모 객체를 생성한 후 자식 객체를 생성한다.


추상클래스에 추상메서드는 언제 구현해야 할까?
-자식 클래스들이 반드시 구현해야 하는 메서드가 있다면, 
 우리는 추상 메서드로 해당 메서드를 부모 클래스(추상클래스)에 선언해 둘 수 있다.

추상 클래스를 상속받은 모든 자식 클래스는 반드시 추상 메서드를 오버라이딩 및 재정의하여 구현해야 한다.
그렇지 않으면 컴파일 에러가 발생한다.

추상클래스와 추상메서드의 용도
- 자식 클래스 간의 공통적인 필드와 메서드 이름을 통일할 수 있다.
- 반드시 구현해야 하는 메서드를 선언함으로써 공통 규격을 제공한다.

인터페이스
-모든 메서드가 추상 메서드인 추상클래스를 '인터페이스'라고 부른다.
-인터페이스는 추상메서드와 상수로만 이루어져있으며,
 추상클래스와 마찬가지로 스스로 객체를 생성할 수 없다.

인터페이스의 선언
-인터페이스는 클래스가 아니다.
-추상클래스는 스스로 객체를 생성할 수는 없지만, 자식 클래스의 생성자를 통해 객체를 생성해낼 수 있었다.
-하지만 인터페이스는 어떤 형태로도 객체를 만들 수 없기 때문에 클래스라고 부를 수 없다.
-인터페이스는 객체의 매개체, 즉, 객체를 사용하는 방법을 제공하는 새로운 블록이라고 할 수 있다.

[접근제한자]interface 인터페이스명{
	상수
	추상메서드
}

-인터페이스를 선언하는 방법은 클래스를 작성하는 방법과 동일하며 class키워드 대신 interface를 작성한다.
-또한, 인터페이스의 추상 메서드는 다른 클래스들과의 매개체 역할을 하므로 누구나 접근할 수 있다.
-따라서 항상 public으로 구현한다.
-만약 접근자를 default로 구현했다면 자동으로 public으로 인식한다.

인터페이스의 장점
-정보은닉 : 실제 구현 클래스의 내용을 전혀 보지 않고도 개발 코드로 객체를 사용할 수 있다.
-모듈화 : 구현 클래스들이 독립적으로 구현되고 사용될 수 있다. 개발 코드에서 객체 변경이 필요할 때, 
 개발코드의 수정을 최소화할 수 있다.

추상 클래스와 인터페이스의 공통점
-정보은닉, 모듈화, 추상화 등은 추상클래스와 인터페이스가 공통적으로 가진 장점이다.
-추상 클래스와 인터페이스 모두 다형성을 구현할 수 있는 기반을 제공하며, 
 추상 메서드 구현에 대한 강제성을 반영하고 있다.






