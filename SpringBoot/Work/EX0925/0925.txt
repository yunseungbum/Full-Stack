HTTP
: 웹에서 클라이언트와 서버 간에 데이터를 주고 받기 위한 프로토콜

HyperText
: 다른 문서로 향하는 링크가 있는 텍스트

Tranfer Protocol
: 통신을 하기 위한 규약

-----------------------------------------------------------------------------------------------------------------------------------
GET /api/users?id=123 HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8
Connection: keep-alive



요청메서드
GET 		서버에서 리소스를 요청할 때 사용			데이터 조회(예: 사용자 정보 가져오기)
POST		서버에 데이터를 전송할 때 사용			데이터 생성 (예: 새로운 게시글 작성)
PUT		서버의 기존 리소스를 업데이트할 때 사용		데이터 수정 (예: 사용자 정보 수정)
DELETE		서버의 리소스를 삭제할 때 사용			데이터 삭제 (예: 게시글 삭제)
PATCH		리소스의 일부를 업데이트할 때 사용			데이터 일부 수정 (예: 특정 필드만 업데이트)
OPTIONS		서버가 지원하는 HTTP 메서드 확인			CORS 설정 확인 및 사전 검사
HEAD		GET과 동일하지만 응답 본문 없이 헤더 정보만 받음	리소스의 존재 여부 확인, 메타데이터 조회
CONNECT	서버에 터널을 설정해 SSL 등과 같은 프로토콜을 사용	프록시 서버를 통한 터널링
TRACE		요청이 서버까지 가는 경로를 추적			네트워크 진단 및 디버깅

-----------------------------------------------------------------------------------------------------------------------------------
HTTP/1.1 200 OK
Date: Tue, 24 Sep 2024 11:00:00 GMT
Content-Type: text/html; charset=UTF-8
Content-Length: 4576
Connection: keep-alive

<html lang="en"> 		//Response Body
</html>			//Response Body


상태코드
상태 코드		이름			설명
200		OK			요청이 성공적으로 처리되었음을 의미
201		Created			요청이 성공했으며, 새로운 리소스가 생성됨
204		No Content		요청이 성공했으나 반환할 콘텐츠가 없음
301		Moved Permanently	요청한 리소스가 영구적으로 다른 위치로 이동했음을 의미
302		Found			요청한 리소스가 일시적으로 다른 위치에 있음을 의미
400		Bad Request		요청이 잘못되어 서버가 이해할 수 없음
401		Unauthorized		인증이 필요함을 나타냄
403		Forbidden		서버가 요청을 거부함
404		Not Found		요청한 리소스를 찾을 수 없음
500		Internal Server Error	서버에서 처리 중 오류가 발생함
502		Bad Gateway		서버가 게이트웨이 또는 프록시로부터 잘못된 응답을 받음
503		Service Unavailable		서버가 요청을 처리할 수 없음 (과부하 또는 유지 보수 상태)

Date
: 서버가 응답을 보낸 시간.

Content-Type
: 응답의 미디어 타입을 의미한다.


콘텐츠 유형의 종류
Content-Type				설명					예시
text/html					HTML 문서				웹 페이지 콘텐츠 (HTML 파일)
text/plain					일반 텍스트 파일				단순 텍스트 파일
application/json				JSON 데이터				API 응답, JSON 형식 데이터
application/xml				XML 데이터				XML 형식의 API 응답 또는 데이터
application/javascript			JavaScript 파일				웹 페이지에서 사용하는 자바스크립트 코드
application/x-www-form-urlencoded		폼 데이터 (키-값 쌍)로 인코딩된 데이터		HTML 폼 제출 시 주로 사용
multipart/form-data			파일 업로드를 포함한 폼 데이터		파일 업로드와 함께 전송되는 데이터
image/png				PNG 이미지				PNG 포맷의 이미지 파일
image/jpeg				JPEG 이미지				JPEG 포맷의 이미지 파일
image/gif					GIF 이미지				GIF 포맷의 이미지 파일
audio/mpeg				MPEG 오디오 파일				MP3 파일
video/mp4				MP4 비디오 파일				MP4 비디오 파일
application/pdf				PDF 문서					PDF 파일
application/zip				ZIP 압축 파일				ZIP 압축된 파일

Content-Length
: 응답 본문의 길이 (바이트 단위).


Connection
keep-alive (연결 유지)
: 클라이언트가 서버와의 연결을 유지하려고 할 때 사용된다.
: 장점: 여러 요청을 할 때 매번 새로운 연결을 생성하지 않아도 되므로 성능이 향상된다.

close (연결 종료)
: 요청과 응답이 끝난 후 연결을 즉시 닫겠다는 의미다.
: 장점: 서버 리소스를 절약할 수 있으나, 매번 새로운 연결을 생성해야 하므로 성능이 떨어질 수 있다.


Response Body
: Response Body는 HTTP 응답의 일부로, 클라이언트가 요청한 리소스나 데이터를 포함하는 본문이다.
: 서버가 요청을 처리한 후 클라이언트에게 반환하는 실제 콘텐츠가 이 부분에 담긴다.

---------------------------------------------------------------------------------------------------------------------------------------
JSON(JavaScript Object Notation)
- 데이터를 저장하고 전송하는 데 사용되는 경량의 데이터 교환 형식이다.
- 사람과 기계 모두 읽고 쓰기 쉽도록 설계되었으며, 주로 웹에서 클라이언트와 서버 간의 데이터 교환 형식으로 많이 사용된다.


JSON의 주요 특징
-텍스트 기반:
JSON은 텍스트로 구성되어 있으며, 사람이 읽기 쉬운 구조를 갖는다.
주로 데이터를 네트워크를 통해 전송하거나 파일로 저장하는 데 적합하다.

-언어 독립적:
JSON은 특정 프로그래밍 언어에 종속되지 않는다.
대부분의 프로그래밍 언어에서 JSON을 쉽게 파싱하거나 생성할 수 있는 라이브러리를 제공한다.

-키-값 쌍:
JSON 데이터는 키-값 쌍의 구조로 이루어진다.
각 키는 문자열로 나타내고, 값은 다양한 자료형(문자열, 숫자, 배열, 객체 등)이 될 수 있다.

-데이터 구조 표현:
JSON은 객체, 배열, 숫자, 문자열, true, false, null과 같은 자료형을 표현할 수 있어, 복잡한 데이터 구조를 직관적으로 표현할 수 있다.


JSON의 기본 구조:
	{
    "name": "John",
    "age": 30,
    "city": "New York"
	}
	
JSON의 장점
경량:
-데이터의 표현이 간결하여 네트워크를 통해 데이터를 효율적으로 전송할 수 있다.
호환성:
-대부분의 프로그래밍 언어에서 JSON을 지원하며, 데이터를 쉽게 파싱하고 생성할 수 있다.
가독성:
-사람이 읽고 쓰기 쉬운 구조로 되어 있어, 디버깅과 유지보수에 유리하다.

-----------------------------------------------------------------------------------------------------------------------------------
서버
-프로그램
-클라이언트가 연결할 때까지 무한히 대기하며 기다린다.
-클라이언트가 연결하면 해당 클라이언트 소켓에서 요청을 받아와 수행하고 응답을 작성해 전달한다.


동적 웹 서버란?
-클라이언트의 요청에 따라 실시간으로 데이터를 처리하고 응답하는 서버다.


-----------------------------------------------------------------------------------------------------------------------------------
스프링

스프링 프레임워크에서 제공하는 주요 서브 프레임워크
1.스프링 코어 (Spring Core)
-설명: 		스프링의 핵심 모듈로, **의존성 주입(DI)**과 **제어의 역전(IoC)**을 지원한다. 스프링의 기본적인 애플리케이션 구성을 위한 모듈이다.
-주요 기능: 	빈(bean) 설정 및 관리, 의존성 주입, IoC 컨테이너 관리.

2. 스프링 AOP (Aspect-Oriented Programming)
설명:		 관점 지향 프로그래밍을 지원하는 모듈로, 공통적으로 적용되는 관심사를 분리하여 코드 중복을 줄이고 유지보수성을 높인다.
주요 기능:	 로깅, 보안, 트랜잭션 관리, 예외 처리 등 공통 로직의 분리.

3. 스프링 ORM (Spring ORM)
설명:		스프링 프레임워크에서 **객체와 관계형 데이터베이스 간의 매핑(ORM)**을 지원하는 모듈이다.
	 	스프링 ORM은 자바 객체와 데이터베이스 테이블 간의 상호작용을 간소화하고, 데이터베이스 연동에 필요한 복잡한 코드를 줄여준다.
		다양한 ORM 프레임워크를 지원하며, 스프링의 트랜잭션 관리와 통합되어 데이터베이스 작업을 효율적으로 처리할 수 있다.
---------------------------------------------------------------------------------------------------------------------------------------------------------

IoC (Inversion of Control, 제어의 역전)
-프레임워크나 컨테이너가 대신 관리하도록 하는 디자인 패턴이다.

IoC의 주요 개념:
1.의존성 주입 (Dependency Injection, DI):
-객체가 스스로 의존성을 관리하는 것이 아니라, 외부에서 필요한 의존성을 주입하는 방식이다.

2.제어의 역전:
- IoC에서는 객체의 생성과 라이프사이클을 스프링 컨테이너가 제어하게 된다.

3.스프링 IoC 컨테이너:
-스프링에서 IoC는 ApplicationContext 또는 BeanFactory라는 IoC 컨테이너를 통해 구현된다


IoC의 동작 방식:
1.객체 등록 (빈 등록):
-스프링 IoC 컨테이너는 **빈(Bean)**이라는 형태로 객체를 관리한다.

2.의존성 주입:
-객체(빈) 간의 의존성은 컨테이너가 객체를 생성할 때 자동으로 주입한다.

3.빈 생성과 라이프사이클 관리:
-IoC 컨테이너는 애플리케이션이 실행될 때 모든 빈을 생성하고, 해당 빈의 라이프사이클을 관리한다.

-------------------------------------------------------------------------------------------------------------------------------
클래스 타입 변환
자동 타입 변환 자식 -> 부모

SportCar car = 	new SportCar();
↓↓↓↓↓ 	↓↓↓↓↓↓
Truct car	 =	 new Truck();
 -> 생성자를 모두 바꿔야 하기 때문에

Car car =     new SportCar();
	       ↓↓↓↓↓↓
Car car =     new Truck();
-> 다형성을 이용한 방법 (부모를 이용)




























































