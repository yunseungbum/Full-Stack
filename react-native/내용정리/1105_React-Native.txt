useState

const[state,setter] = useState(초기값)

setter함수는 비동기로 진행
여러번 호출할 경우 반영이 잘 안될 수도 있다.

setter(prev => 이전 상태를 어떻게 바꿀건지)
setter(prev => 이전 상태를 어떻게 바꿀건지)
setter(prev => 이전 상태를 어떻게 바꿀건지)

setter함수안에서 함수를 호출하면 여러번 호출해도 문제가 생기지 않는다.

왜 state로 관리를 하지?
-리엑트는 객체가 새로 만들어져야 수정이 됐다고 생각을 하기 때문에 state사용을 해야한다.
1. 불변성을 통한 상태관리
2. 참조비교를 이용한 변경감지
ㄴ리엑트는 얕은 비교를 사용해 이전상태와 새로운상태를 비교
ㄴ 객체의 참조를 비교(주소)하는 방식으로, 성능이 뛰어나고 불필요한 렌더링을 줄이는데 효과적이다.

함수의 실행을 이벤트가 발생할 때까지 지연시키기 위해서이다.
함수를 호출할 때 vs 함수를 전달할 때

 함수를 호출할 때
-함수가 즉시 실행되어 결과를 반영한다.
-렌더링 될 때마다 실행이 될 수 있다.
onPress = {setCount(prev => prev +1)}

 함수를 전달
-클릭 이벤트가 발생할 때 까지 setcount를 실행하지 않고 기다릴 수 있다.
onPress = {() => {setCount(count+1)}

useEffect
컴포넌트가 렌더링 될 때마다 원하는 작업이 실행되도록 설정할 수 있는 hook

import{userEffect} from 'react'

hook의 호출
useEffext(() => {},[])
첫번째 인자로 useEffect가 어떤 조건하에 하고자하는 명령이 들어있는 함수가 전달된다.
두번째 인자로 useEffect가 언제 실행이 될건지 조건을 정하는 배열
useEffext(() => {}) -> 매 렌더링마다 재실행
useEffext(() => {},[]) -> 컴포넌트가 마운트 될 때 실행
useEffext(() => {},[state1,state2]) -> 해당 state가 변경될 때마다 실행 
마운트: 컴포넌트가 화면에 렌더링

클린업 함수
-컴포넌트가 언마운트 되거나,useEffect가 다시 실행되거 전에 실행하는 함수
-주로 리소스를 정리하거나, 이벤트 리스너를 제거하거나,타이머를 정리하는 등 필요한 뒷처리를 수행하기 위해 사용한다.

클린업 함수 사용하는 방법
- useEffect는 첫 번째 인자로 함수를 받는데,이 함수는 다시 함수를 반환할 수 있다.
- 반환된 함수가 클린업 함수이다.

useEffext(() =>{
	console.log()
	return() => {} 
},[])

return() => {} 이부분이 클린업 함수



useRef
1.특정 엘리먼트를 선택할 수 있다.(.querySelector 처럼 태그를 선택할 수 있다.)

const refName = useRef(null); ->useRef 객체를 만든다.

<StlyedInput ref={refName}>

2. 리렌더링 없이 상태를 유지할 때
useRef의 값이 바뀌어도 재렌더링이 되지 않기 때문에 값이 바뀌어도 렌더링이 필요하지 않은 경우에 사용 할 수 있다

useMemo
- 메모이제이션을 활용해 특정 연산의 결과를 저장해두고, 불필요한 반복 계산을 피하도록 도와준다.
- 이 훅은 복잡한 계산이 매번 다시 이루어지지 않도록 최적화 하는 역할을 하고, 
  의존성 배열에 따라 값이 바뀔 때만 연산이 다시 수행되도록 설정할 수 있다.

useMomo(()=>{},[])

메모이제이션
같은 계산을 반복해야 할 때 그 결과를 저장해두고,다시 필요할 때 저장된 값을 꺼내 사용하는 기법


---------------------------------------------------------------------------------------------------------------------

useEffect의 첫번째 요소인 함수에 비동기 함수가 되면 안되는 이유

1. useEffect 자체가 비동기 동작을 직접적으로 지원을 안함

2. useEffect의 반환값은 반드시 클린업 함수 또는 undifined여야 한다.
   비동기 함수를 사용하면 반환값이 promise가 된다.

3. 비동기 흐름으로 인한 예기치 않은 동작
- useEffect 내부에서 비동기 처리를 직접적으로 작성하면,이 비동기 함수가 
  실행되는 동안 컴포넌트가 재렌더링 될 때,상태가 변화해서 데이터가 꼬이거나,메모리 누수가 발생할 가능성이 높아진다.

anync란?
- 함수 앞에 붙어서 해당 함수가 비동기 작업을 포함하고 있다는 걸 알려주는 키워드
- 비동기 작업을 포함하는 함수에 anync를 붙히게 되면 그 함수는 promise라는 객체를 반환하게 된다.
- promise는 자바스크립트가 이 작업이 완료되면 알려주는 일종의 약속같은 개념이다.

await
- async 함수 안에서만 사용할 수 있는 키워드
- 특정 작업이 완료될 때까지 기다려달라고 요청
  즉,Promise가 완료될 때까지 기다렸다가 결과를 받아서 처리
- await 덕분에 마치 동기 코드처럼 차례대로 실행되는 것처럼 보이지만,
  실제로는 비동기로 작업이 이루어진다.

wait이 비동기인 이유
- 특정 작업을 기다리기는 하지만, 비동기 함수 안에서 일어나기 때문에 함수 바깥쪽 코드들은 멈추지 않는다.


결합도 - 각 모듈간의 연관성 (낮추는게 좋다)
ㄴ 인터페이스를 사용,의존성 주입
응집도 - 하나의 모듈에서 코드들간의 연관성 (높히는게 좋다)
ㄴ 단일 책임의 원칙(하나의 함수는 하나의 기능을 갖는게 좋다)
ㄴ 기능 관련 코드 묶기


Context API

const Context = createContext(defaultValue);

createContext  함수를 호출하면서 매개변수에 전달된 값을 기본값으로 지정할 수 있다.


Consumer
- 컨슈머 컴포넌트는 상위 컴포넌트 중 가장 가까운 곳에 있는 Provider 컴포넌트가 전달하는 데이터를 이용한다.
- 만약 상위 컴포넌트 중 Provider 컴포넌트가 없다면 createContext 함수의 매개변수로 전달된 기본값을 사용한다.










































































