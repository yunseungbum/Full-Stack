다중 인터페이스의 구현
-우리는 하나의 클래스로 여러 개의 인터페이스를 구현할 수 있다.
-선언한 모든 인터페이스에 대한 추상 메서드를 모두 구현해 줘야 한다.

[접근제한자] class 클래스명 implements 인터페이스1,인터페이스2{
	필드
	생성자
	인터페이스1에 대한 구현 메서드
	인터페이스2에 대한 구현 메서드
}


인터페이스 상속
-인터페이스끼리 상속관계를 만들 수 있다.
-클래스에서의 상속과 마찬가지로 extends키워드를 사용하며, 
 상속이 가능하기 때문에 콤마를 이용해서 여러개를 상속하는 것이 가능

[접근제한자] interface 인터페이스명 extends 인터페이스1, 인터페이스2,...{

}

-인터페이스 상속을 선언하면, 하위 인터페이스는 상위 인터페이스의 모든 멤버를 상속받게 된다.
-하위 인터페이스를 구현하는 클래스가 있다면,  해당 클래스는 하위 인터페이스의
 추상메서드를 포함하여 상위 인터페이스의 추상메서드까지 구현해야 한다.

내부클래스
-클래스 안에 만들어진 또 다른 클래스로 중첩클래스라고도 부른다.
- 클래스 안에 다른 클래스를 선언하는 이유는 두 개의 클래스가 서로 긴밀한 관계를 맺고 있기 때문이다.

내부클래스의 장점
-두 클래스 멤버들 간에 손쉽게 접근할 수 있다.
-불필요한 클래스를 감춰서 코드의 복잡성을 줄일 수 있다.

public class OuterClass{
	class InnerClass{

	}
}

내부클래스의 종류

인스턴스 클래스
-외부클래스의 필드와 같은 위치에 선언
-주로 외부클래스의 클래스 멤버 변수와 관련된 작업에 사용될 목적으로 선언

정적클래스
-외부 클래스의 클래스 변수와 같이 static키워드 부여

지역클래스
-외부클래스의 "메서드 내부에서 선언"하여 사용
-메서드 영역에서 선언되기 때문에 메서드 내부에서만 사용 가능

인스턴스 클래스
-외부클래스 내부에서 생성하고, 선언되어 사용하는 클래스
-외부클래스의 필드와 같은 위치에 선언하며,외부 클래스의 필드처럼 다뤄진다.
-주로 외부클래스의 필드들과 관련된 작업에 사용될 목적으로 선언된다.

public class Outer{
	private String name; -> 필드

	//인스턴스 클래스가 들어갈 수 있다.
	public class Inner{
		private String name;
	}

}
-내부클래스도 외부 클래스 안에 생성되는 것 외에는 별도의 클래스 이기 때문에,
 파일이 컴파일 되면 별도로 생성된다.

인스턴스 클래스의 객체화
-인스턴스 클래스는 기본적인 내부클래스이다.
-외부 클래스 안에 생성되기 때문에, 클래스를 사용하려면 외부 클래스의 객체가
 생성된 상태에서 객체를 생성할 수 있다.

Outer outer = new Outer(); //외부 클래스 객체 생성
Outer.Inner in = Outer.new Inner(); //외부 클래스를 이용해 내부 클래스 객체 생성


정적 내부 클래스(staticx class)
-클래스 안에 정적 변수를 선언할 수 있는 것처럼 클래스도 정적 클래스를 만들 수 있다.
-필드(멤버)와 마찬가지로 static키워드를 사용해 클래스를 선언한 후 정적 내부 클래스를 생성한다.
-주로 외부 클래스의 static메서드에서 사용될 목적으로 만든다.

public class Outer{
	private String name;
	public static class Inner{
		private STring name;
	}
}
-외부 클래스의 필드 또는 메서드를 정적 내부 클래스 안에서는 사용할 수 없다.

public class Outer{
	private int val1; //필드

	public static class Inner{
		public void add(){
			int result = val1 + 10; -> 에러
		}
		
	}
}

-정적 내부 클래스는 정적 변수 또는 정적메서드를 호출하는 것이 가능하다.

public class Outer{
	private int val1; //필드
	private static int cnt = 1; //정적변수

	public static class Inner{
		public void displayOuterInfo(){
			System.out.println(val); -> 에러
			System.out.println(cnt);
		}
		
	}
}

정적 내부 클래스의 객체 생성
Outer.Inner in = new Outer.Inner();

지역클래스(local class)
-지역 클래스는 외부 클래스의 메서드 내에서 선언되어 사용하는 클래스이다.
-메서드 내에서 선언되기 때문에 해당 클래스는 메서드 내에서만 사용할 수 있다.
-메서드의 실행이 끝나면 해당 클래스도 사용이 종료된다.

public class LocalClass{
	public void print(){
		///////////////////
		class A{
				지역 클래스 선언
		}

		A a = new A();	메서드 내에서 사용
		//////////////////

	}

}

내부 클래스의 접근 제한
-내부클래스도 클래스이기 때문에 접근제한자를 붙여 사용할 수 있다.

지역클래스의 접근 제한
-지역 클래스는 메서드 내에서 선언되어 사용한다.
-보통 메서드가 종료되면 클래스도 함께 종료되지만 메서드와 실행되는 위치가 다르기 때문에 
 종료되지 않고 남아있을 수도 있다.
-그래서 지역 클래스에서 메서드 내의 변수를 사용할 때는 변수를 복사해 사용한다.
-이러한 이유로 지역 클래스에서 메서드의 변수를 사용할 때 해당 변수가 변경되면 오류가 발생한다.

익명클래스(anonymous class)
-이름이 없는 클래스
-익명클래스는 클래스의 선언과 객체의 생성을 동시에 하므로
 한번만 사용할 수 있다.
-오직 하나의 객체만을 생성할 수 있는 일회용 클래스이다.
-따라서 생성자를 선언할 수도 없으며, 둘 이상의 인터페이스를 구현할 수도 없다.


-------------------------------------------------------------------------------------------------------------

예외처리
에러(error)와 예외(exception)
-자바 프로그램을 실행하다 보면 갑자기 프로그램이 종료되거나, 어떤 원인에 의해 잘못 동작하여 
 오류 메세지가 나타나는 등 예기치 못한 오류가 발생한다.
-전자는 우리가 해결할 수 없는 시스템에 에러가 발생해 프로그램이 종료된 경우이며 
 후자는 프로그램 사용 중 발생한 오류를 개발자가 처리해 메세지가 출력된 경우이다.

에러(error)
-시스템에 비정상적인 상황이 생겼을 때 발생한다.
-외부 요인일 수도 있고, 프로그램 구동 중에 발생하는 치명적인 오류일 수도 있다.
-이러한 에러들은 개발자가 예측하거나 처리할 수 없는 영역이다.

에러의 종류			상황
OutOfMemoryError		프로그램 실행 중 메모리 부족
IOError				입출력 에러
StackOverFlowError		가용 메모리 부족 현상, 재귀 호출 문제시 발생

예외(exception)
-대체로 프로그램 구동 중에 나타나는 오류들
-문법적으로는 문제가 없어 보이지만 실제 운영 중에 생기는 문제들
-체크예외 비체크 예외 두가지가 있다.

체크 예외
-자바 소스를 컴파일 하는 과정에서 검사한다.
-보통 문법적으로 강제하여 예외 처리를 해야 하는 경우

비체크 예외
-컴파일 과정에서 검사하지 않으므로 사용자의 경험이나 테스트로 찾아야 하는 경우

예외클래스
-자바는 객체지향언어이다
-따라서 프로그램에서 발생하는 예외들은 클래스 형태로 제공된다.

NullPointerException
-객체가 제대로 생성되지 않은 상태에서 사용할 경우 발생한다.
-우리가 객체를 선언하면 객체는 주소를 가지게 되고, 그것을 통해 객체에 접근해 값을 가져온다.
-객체는 정의되었는데 실제 메모리에 생성되지 않았을 경우 예외가 발생한다.

예외처리문법
-예외가 발생했을 때, 어떻게 예외 처리를 하는지 방법에 대해서 알아보자

예외처리 과정
-코드 진행 중 예외가 발생하면 JVM에게 알린다
-JVM은 발생한 예외를 분석하여 알맞은 예외 클래스를 생성한다
-생성된 예외 객체를 발생한 지점으로 보낸다
-예외가 발생한 지점에서 처리하지 않으면 프로그램은 비정상 종료된다.

try - catch 구문
-예외를 처리하는 가장 기본 문법은 try - catch문이다.
-예외가 발생할 가능성이 있는 코드는 try{}안에 작성하고
-catch 메서드는 시스템으로부터 넘어오는 예외 클래스를 받아서 처리한다.

try {
    예외가 발생할 가능성이 있는 코드
} catch (예외 클래스명 e) {
    예외처리 코드
}


예외 던지기
-메서드 내부에서 예외를 처리하지 않고 미룬 후, 해당 메서드를 호출한 쪽에서 
 예외를 처리하는 방법을 '예외 던지기'라고 한다

throws
-메서드 뒤에 throws키워드를 사용하여 던지기 할 예외 객체를 붙여주면된다.
-예외 객체는 여러 개를 던질 수 있으며, 여러 개를 던질 시에는 콤마(,)로 구분해서 나열해준다.





















